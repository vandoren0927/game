<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>豎屏動作小遊戲（類SAO手感）</title>
  <style>
    :root{
      --bg:#070a12;
      --panel:#0f1627;
      --line:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --good:#42f59e;
      --bad:#ff4d4d;
      --accent:#00d4ff;
      --gold:#ffd166;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 50% -10%, #1a2450 0%, var(--bg) 55%, #04050a 100%);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Noto Sans TC", "Segoe UI", Roboto, Arial, sans-serif;
      overscroll-behavior: none;
      touch-action: none;
    }

    .wrap {
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;
      box-sizing: border-box;
    }

    .game-shell{
      width: min(430px, 100%);
      aspect-ratio: 9/16; /* 豎屏 */
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      background: rgba(0,0,0,.25);
      border-bottom: 1px solid var(--line);
      backdrop-filter: blur(8px);
    }

    .badge{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(15,22,39,.55);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .bar{
      flex: 1;
      height: 10px;
      border: 1px solid var(--line);
      border-radius: 999px;
      overflow: hidden;
      background: rgba(0,0,0,.35);
      position: relative;
      min-width: 90px;
    }
    .bar > .fill{
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--good), #2bd2ff);
      transform-origin: left center;
      transform: scaleX(1);
    }
    .bar.hp > .fill{
      background: linear-gradient(90deg, #6cf5a9, #1dd6ff);
    }
    .bar.sp > .fill{
      background: linear-gradient(90deg, #7c4dff, #00d4ff);
    }

    .canvas-wrap{
      position: relative;
      flex: 1;
      background: linear-gradient(180deg, rgba(0,212,255,.10), rgba(0,0,0,0));
    }

    canvas{
      width: 100%;
      height: 100%;
      display:block;
    }

    .hud-tip{
      position:absolute;
      left: 10px;
      right: 10px;
      bottom: 102px;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(15,22,39,.55);
      backdrop-filter: blur(8px);
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }

    .controls{
      display:flex;
      gap:10px;
      padding: 10px 12px 12px 12px;
      background: rgba(0,0,0,.25);
      border-top: 1px solid var(--line);
    }

    .btn{
      flex:1;
      border: 1px solid var(--line);
      background: rgba(15,22,39,.65);
      color: var(--text);
      border-radius: 14px;
      padding: 12px 10px;
      font-weight: 700;
      letter-spacing: .2px;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      user-select: none;
      -webkit-user-select: none;
      cursor: pointer;
    }
    .btn:active{
      transform: translateY(1px);
      filter: brightness(1.05);
    }
    .btn.primary{ border-color: rgba(0,212,255,.45); }
    .btn.warn{ border-color: rgba(255,77,77,.45); }
    .btn.small{
      flex: .9;
      font-weight: 700;
      font-size: 12px;
      padding: 12px 8px;
      color: var(--muted);
    }

    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      z-index: 50;
      padding: 16px;
      box-sizing: border-box;
    }
    .card{
      width: min(360px, 100%);
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(15,22,39,.75);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .card h1{
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    .card p{
      margin: 8px 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
    }
    .row{
      display:flex;
      gap:10px;
      margin-top: 12px;
    }
    .row .btn{ flex: 1; }

    .mini{
      font-size: 12px;
      color: var(--muted);
      opacity: .9;
      margin-top: 10px;
    }

    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding: 2px 8px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(0,0,0,.25);
      color: var(--muted);
      font-size: 12px;
      margin-right: 6px;
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="game-shell" id="shell">
    <div class="topbar">
      <div class="badge"><span>HP</span><div class="bar hp"><div class="fill" id="hpFill"></div></div></div>
      <div class="badge"><span>SP</span><div class="bar sp"><div class="fill" id="spFill"></div></div></div>
      <div class="badge">分數：<b id="score">0</b></div>
      <div class="badge">波次：<b id="wave">1</b></div>
    </div>

    <div class="canvas-wrap">
      <canvas id="c"></canvas>

      <div class="hud-tip" id="tip">
        <span class="pill">操作</span>
        點「跳躍」或輕點畫面：跳<br>
        點「普攻」：斬擊（近距離）<br>
        點「閃避」或向左快速滑：無敵翻滾（耗 SP）<br>
        連續命中會提升連擊，傷害略增。
      </div>

      <div class="overlay" id="overlay">
        <div class="card">
          <h1>豎屏動作小遊戲（類SAO手感）</h1>
          <p>玩法：左右自動跑動（你只要專注跳、砍、閃）。擊敗怪物得分，血量歸零就結束。</p>
          <p>提示：閃避有短暫無敵但會消耗 SP；SP 會隨時間回復。</p>
          <div class="row">
            <button class="btn primary" id="startBtn">開始遊戲</button>
            <button class="btn small" id="muteBtn">音效：開</button>
          </div>
          <div class="mini">離線可玩。若你要更像「記憶重組」：我也可以再加「格擋/Parry」「必殺技」「抽角色 UI」。</div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="jumpBtn">跳躍</button>
      <button class="btn primary" id="atkBtn">普攻</button>
      <button class="btn warn" id="dashBtn">閃避</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);

  // ===== UI =====
  const hpFill = document.getElementById('hpFill');
  const spFill = document.getElementById('spFill');
  const scoreEl = document.getElementById('score');
  const waveEl = document.getElementById('wave');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const muteBtn = document.getElementById('muteBtn');

  const jumpBtn = document.getElementById('jumpBtn');
  const atkBtn  = document.getElementById('atkBtn');
  const dashBtn = document.getElementById('dashBtn');

  // ===== Simple SFX (WebAudio) =====
  let audioOn = true;
  let audioCtx = null;
  function beep(freq=440, dur=0.06, type="sine", gain=0.05){
    if(!audioOn) return;
    try {
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    } catch(e){}
  }

  muteBtn.addEventListener('click', () => {
    audioOn = !audioOn;
    muteBtn.textContent = `音效：${audioOn ? '開' : '關'}`;
    beep(audioOn ? 660 : 220, 0.05, "square", 0.04);
  });

  // ===== Game state =====
  const W = () => canvas.getBoundingClientRect().width;
  const H = () => canvas.getBoundingClientRect().height;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);

  let running = false;
  let last = 0;

  // World
  const groundY = () => H() * 0.84;
  const laneDepth = () => H() * 0.06;

  // Player
  const player = {
    x: () => W()*0.42,
    y: 0,
    vy: 0,
    w: 24,
    h: 42,
    onGround: true,
    facing: 1,
    hp: 100,
    sp: 100,
    invuln: 0, // seconds
    atkCd: 0,
    dashCd: 0,
    combo: 0,
    comboTimer: 0,
  };

  // Enemies
  let enemies = [];
  let particles = [];
  let score = 0;
  let wave = 1;
  let spawnTimer = 0;

  function resetGame(){
    player.y = groundY() - player.h;
    player.vy = 0;
    player.onGround = true;
    player.hp = 100;
    player.sp = 100;
    player.invuln = 0;
    player.atkCd = 0;
    player.dashCd = 0;
    player.combo = 0;
    player.comboTimer = 0;

    enemies = [];
    particles = [];
    score = 0;
    wave = 1;
    spawnTimer = 0;

    scoreEl.textContent = score;
    waveEl.textContent = wave;
    updateBars();
  }

  function updateBars(){
    hpFill.style.transform = `scaleX(${clamp(player.hp/100,0,1)})`;
    spFill.style.transform = `scaleX(${clamp(player.sp/100,0,1)})`;
  }

  function spawnEnemy(){
    const side = Math.random() < 0.5 ? -1 : 1;
    const x = side < 0 ? -40 : W() + 40;
    const y = groundY() - 38;
    const base = 22 + wave * 2;
    enemies.push({
      x, y,
      w: 26, h: 38,
      vx: side < 0 ? rand(55, 85) : rand(-85, -55),
      hp: clamp(base, 20, 140),
      maxhp: clamp(base, 20, 140),
      hitstun: 0,
      kind: Math.random() < 0.18 ? "elite" : "mob"
    });
  }

  function addHitParticles(x,y, good=true){
    const n = 10;
    for(let i=0;i<n;i++){
      particles.push({
        x, y,
        vx: rand(-140,140),
        vy: rand(-220,-60),
        life: rand(0.25,0.5),
        t: 0,
        good
      });
    }
  }

  // ===== Actions =====
  function jump(){
    if(!running) return;
    if(player.onGround){
      player.vy = -420;
      player.onGround = false;
      beep(520, 0.05, "triangle", 0.05);
    }
  }

  function attack(){
    if(!running) return;
    if(player.atkCd > 0) return;

    player.atkCd = 0.22;
    beep(880, 0.04, "square", 0.04);

    // Hitbox in front of player
    const px = player.x();
    const py = player.y;
    const range = 54;
    const hb = {
      x: px - range/2,
      y: py + 6,
      w: range,
      h: player.h - 12
    };

    // Damage scaling by combo
    const comboMul = 1 + Math.min(0.4, player.combo * 0.04);
    const dmg = Math.round((18 + wave*1.2) * comboMul);

    let hit = 0;
    for(const e of enemies){
      if(e.hitstun > 0) continue;
      if(rectHit(hb, e)){
        hit++;
        e.hp -= dmg;
        e.hitstun = 0.08;
        addHitParticles(e.x + e.w/2, e.y + e.h/2, true);
        if(e.hp <= 0){
          score += (e.kind === "elite" ? 60 : 30) + Math.round(wave*4);
          player.combo++;
          player.comboTimer = 1.25;
          beep(1040, 0.05, "sawtooth", 0.03);
        } else {
          score += 5;
          player.combo++;
          player.comboTimer = 1.25;
        }
      }
    }

    if(hit === 0){
      // Miss -> combo decays a bit
      player.combo = Math.max(0, player.combo - 1);
    }

    scoreEl.textContent = score;
  }

  function dash(){
    if(!running) return;
    if(player.dashCd > 0) return;
    if(player.sp < 25) {
      beep(160, 0.07, "sine", 0.05);
      return;
    }
    player.sp -= 25;
    player.invuln = 0.32;
    player.dashCd = 0.65;

    // Quick reposition
    const shift = 90;
    // If there is threat on the right, shift left; else random
    const threatRight = enemies.some(e => e.x > player.x() && Math.abs(e.x - player.x()) < 120);
    const dir = threatRight ? -1 : (Math.random()<0.5 ? -1 : 1);
    // Clamp inside screen
    const nx = clamp(player.x() + dir*shift, 30, W()-30);

    // Since x is getter, we fake with camera offset by moving enemies opposite direction.
    const dx = nx - player.x();
    for(const e of enemies) e.x -= dx;
    for(const p of particles) p.x -= dx;

    beep(320, 0.06, "triangle", 0.05);
    updateBars();
  }

  function rectHit(a, b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // ===== Touch gestures (tap / swipe) =====
  let touchStart = null;
  canvas.addEventListener('pointerdown', (e) => {
    if(!running) return;
    touchStart = { x: e.clientX, y: e.clientY, t: performance.now() };
  }, {passive:false});

  canvas.addEventListener('pointerup', (e) => {
    if(!running || !touchStart) return;

    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const dt = performance.now() - touchStart.t;

    const adx = Math.abs(dx), ady = Math.abs(dy);

    // Tap
    if(adx < 12 && ady < 12 && dt < 220){
      jump();
      touchStart = null;
      return;
    }

    // Swipe: left = dash, right = attack
    if(adx > ady && adx > 40 && dt < 420){
      if(dx < 0) dash();
      else attack();
    }
    touchStart = null;
  }, {passive:false});

  // ===== Buttons =====
  jumpBtn.addEventListener('click', jump);
  atkBtn.addEventListener('click', attack);
  dashBtn.addEventListener('click', dash);

  // ===== Start/Restart =====
  startBtn.addEventListener('click', () => {
    overlay.style.display = 'none';
    running = true;
    last = performance.now();
    beep(660, 0.05, "sine", 0.04);
    requestAnimationFrame(loop);
  });

  // ===== Main loop =====
  function loop(t){
    if(!running) return;
    const dt = Math.min(0.033, (t - last)/1000);
    last = t;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  function update(dt){
    // cooldowns
    player.atkCd = Math.max(0, player.atkCd - dt);
    player.dashCd = Math.max(0, player.dashCd - dt);
    player.invuln = Math.max(0, player.invuln - dt);

    // combo
    if(player.comboTimer > 0){
      player.comboTimer -= dt;
      if(player.comboTimer <= 0) player.combo = 0;
    }

    // SP regen
    player.sp = clamp(player.sp + 18*dt, 0, 100);

    // gravity
    player.vy += 980 * dt;
    player.y += player.vy * dt;
    if(player.y >= groundY() - player.h){
      player.y = groundY() - player.h;
      player.vy = 0;
      player.onGround = true;
    }

    // spawning
    spawnTimer -= dt;
    const targetEnemies = 2 + Math.floor(wave*0.6);
    if(spawnTimer <= 0 && enemies.length < targetEnemies){
      spawnEnemy();
      spawnTimer = rand(0.55, 1.05);
    }

    // enemy update + attacks
    for(const e of enemies){
      e.hitstun = Math.max(0, e.hitstun - dt);

      // Slightly home toward player (center region)
      const px = player.x();
      const dirToPlayer = Math.sign(px - e.x) || 1;

      // Elite is faster
      const speedMul = (e.kind === "elite") ? 1.25 : 1;
      e.x += (e.vx + dirToPlayer*18) * speedMul * dt;

      // Enemy touches player -> damage unless invuln
      const pRect = { x: player.x() - player.w/2, y: player.y, w: player.w, h: player.h };
      if(rectHit(pRect, e)){
        if(player.invuln <= 0){
          const dmg = e.kind === "elite" ? 14 : 9;
          player.hp -= dmg;
          player.invuln = 0.35;
          player.combo = 0;
          player.comboTimer = 0;
          addHitParticles(player.x(), player.y + player.h/2, false);
          beep(220, 0.06, "sawtooth", 0.05);
        }
      }
    }

    // remove dead
    enemies = enemies.filter(e => e.hp > 0);

    // wave progression
    if(score > wave * 220){
      wave++;
      waveEl.textContent = wave;
      beep(740, 0.08, "triangle", 0.04);
    }

    // particles
    for(const p of particles){
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 900 * dt;
    }
    particles = particles.filter(p => p.t < p.life);

    updateBars();

    // game over
    if(player.hp <= 0){
      running = false;
      showGameOver();
    }
  }

  function showGameOver(){
    overlay.style.display = 'flex';
    overlay.innerHTML = `
      <div class="card">
        <h1>結束</h1>
        <p>你的分數：<b style="color:var(--gold)">${score}</b></p>
        <p>到達波次：<b>${wave}</b></p>
        <p style="color:rgba(255,255,255,.72)">想更像 SAO 記憶重組：我可以加「格擋判定（完美格擋）」「必殺技條」「角色切換」。</p>
        <div class="row">
          <button class="btn primary" id="againBtn">再來一局</button>
          <button class="btn small" id="closeBtn">回到封面</button>
        </div>
      </div>
    `;
    document.getElementById('againBtn').addEventListener('click', () => {
      resetGame();
      overlay.style.display = 'none';
      running = true;
      last = performance.now();
      requestAnimationFrame(loop);
      beep(660, 0.05, "sine", 0.04);
    });
    document.getElementById('closeBtn').addEventListener('click', () => {
      location.reload();
    });
  }

  // ===== Render =====
  function draw(){
    const w = W(), h = H();
    ctx.clearRect(0,0,w,h);

    // Background: parallax-ish lines
    drawBackground(w,h);

    // Ground
    const gy = groundY();
    ctx.fillStyle = "rgba(255,255,255,.06)";
    ctx.fillRect(0, gy, w, h-gy);

    // Lane line
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, gy - laneDepth());
    ctx.lineTo(w, gy - laneDepth());
    ctx.stroke();

    // Player
    drawPlayer();

    // Enemies
    for(const e of enemies){
      drawEnemy(e);
    }

    // Attack indicator (small hint when atkCd just triggered)
    if(player.atkCd > 0.18){
      drawSlashArc();
    }

    // Particles
    for(const p of particles){
      const alpha = 1 - (p.t / p.life);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.good ? "rgba(66,245,158,.9)" : "rgba(255,77,77,.9)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Text overlays
    drawTexts();
  }

  function drawBackground(w,h){
    // soft stars
    ctx.fillStyle = "rgba(255,255,255,.03)";
    for(let i=0;i<18;i++){
      const x = (i*97 + (score*0.7)) % w;
      const y = (i*71) % (h*0.65);
      ctx.fillRect(x, y, 2, 2);
    }

    // horizon glow
    const gy = groundY();
    const grd = ctx.createLinearGradient(0, gy-220, 0, gy+10);
    grd.addColorStop(0, "rgba(0,212,255,.10)");
    grd.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grd;
    ctx.fillRect(0, gy-220, w, 240);
  }

  function drawPlayer(){
    const x = player.x();
    const y = player.y;

    // body
    ctx.save();
    // invuln flash
    if(player.invuln > 0){
      ctx.globalAlpha = 0.65;
    }
    ctx.fillStyle = "rgba(255,255,255,.88)";
    roundRect(x - player.w/2, y, player.w, player.h, 8);
    ctx.fill();

    // scarf/accent
    ctx.fillStyle = "rgba(0,212,255,.75)";
    roundRect(x - player.w/2, y + 10, player.w, 8, 6);
    ctx.fill();

    // sword
    ctx.strokeStyle = "rgba(255,255,255,.85)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x + 10, y + 18);
    ctx.lineTo(x + 32, y + 8);
    ctx.stroke();

    ctx.restore();
  }

  function drawEnemy(e){
    // enemy box
    ctx.fillStyle = (e.kind === "elite") ? "rgba(255,209,102,.78)" : "rgba(255,77,77,.72)";
    roundRect(e.x, e.y, e.w, e.h, 8);
    ctx.fill();

    // hp mini
    const bw = e.w, bh = 5;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    roundRect(e.x, e.y - 10, bw, bh, 999);
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.85)";
    roundRect(e.x, e.y - 10, bw * clamp(e.hp/e.maxhp,0,1), bh, 999);
    ctx.fill();
  }

  function drawSlashArc(){
    const x = player.x();
    const y = player.y + player.h/2;
    ctx.strokeStyle = "rgba(0,212,255,.65)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x+18, y, 26, -0.8, 0.8);
    ctx.stroke();
  }

  function drawTexts(){
    // combo
    if(player.combo > 1 && player.comboTimer > 0){
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "700 14px -apple-system, BlinkMacSystemFont, Noto Sans TC, sans-serif";
      ctx.fillText(`COMBO x${player.combo}`, 12, 22);
    }

    // low hp warning
    if(player.hp < 30){
      ctx.fillStyle = "rgba(255,77,77,.85)";
      ctx.font = "700 12px -apple-system, BlinkMacSystemFont, Noto Sans TC, sans-serif";
      ctx.fillText("警告：HP 低", 12, 42);
    }

    // hints
    ctx.fillStyle = "rgba(255,255,255,.55)";
    ctx.font = "12px -apple-system, BlinkMacSystemFont, Noto Sans TC, sans-serif";
    ctx.fillText("滑右=普攻｜滑左=閃避｜點一下=跳", 12, H()-12);
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ===== Prevent page scroll / gestures =====
  document.addEventListener('touchmove', (e) => e.preventDefault(), {passive:false});

  // init
  resize();
  resetGame();
})();
</script>
</body>
</html>